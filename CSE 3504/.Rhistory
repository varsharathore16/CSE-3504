x <- c(1:6)
probability <- c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6)
plot(x, probability, type="h", xlab="x", ylab="Probability", title="Rolling a die")
plot(x, (1:6)/6, type="h", xlab="x", ylab="Probability")
plot(x, (1:6)/6, type="s", xlab="x", ylab="Probability")
weeks <- c(9, 14, 13, 9, 4, 2, 1)
sum(weeks)
probability <- weeks/52
probability
round(probability, 2)
failures <- 0:6
plot(failures, probability, xlab="number of hardware failures in a week", ylab="probability", type="h")
cumprob <- cumsum(round(probability, 2))
plot(failures, cumprob, type="s", xlab="number of hardware failures in a week", ylab="cumulative probability")
clear
dbinom(n, size=5, prob = 0.95)
n <- 0:5
dbinom(n, size=5, prob = 0.95)
prob <- dbinom(n, size=5, prob = 0.95)
plot(n, prob, type="h")
prob <- dbinom(n, size=5, prob = 0.90)
plot(n, prob, type="h")
prob <- dbinom(n, size=5, prob = 0.99)
plot(n, prob, type="h")
choose(100, 2)
choose(20, 2)
choose(2, 100)
choose(2, 20)
choose(100, 20)
choose(20, 100)
choose(36, 6)
1 - pbinom(30, 50, 0.5)
n <- 1:200
plot(n, 0.999^n, ylim=c(0.9, 1))
0.999^106
0.999^107
0.999^105
dgeom(4, 0.03)
pgeom(4, 0.03)
qgeom(0.75, 0.2)
prod(36:31)/(36^6)
1 - pbirthday(n = 700, classes = 700, coincident = 50)
pbirthday(n = 700, classes = 700, coincident = 50)
min_servers
print(min_servers)
min_servers
pbirthday(n = 700, classes = 20, coincident = 50)
1 - pbirthday(n = 700, classes = 20, coincident = 50)
1 - pbirthday(n = 700, classes = 25, coincident = 50)
1 - pbirthday(n = 700, classes = 21, coincident = 50)
1 - pbirthday(n = 700, classes = 22, coincident = 50)
1 - pbirthday(n = 700, classes = 23, coincident = 50)
1 - pbirthday(n = 700, classes = 20, coincident = 50)
1 - pbirthday(n = 700, classes = 21, coincident = 50)
stack_sizes <- c(0, 1, 2, 3, 4, 5, 6, 7)
frequencies <- c(100, 200, 500, 500, 400, 200, 80, 20)
total_observations <- sum(frequencies)
pmf <- frequencies / total_observations
cdf <- cumsum(pmf)
data_table <- data.frame(Stack_Size = stack_sizes, Frequency = frequencies, PMF = pmf, CDF = cdf)
print(data_table)
barplot(pmf, names.arg = stack_sizes, xlab = "Stack Size", ylab = "PMF", main = "Probability Mass Function")
plot(stack_sizes, cdf, type = "s", xlab = "Stack Size", ylab = "CDF", main = "Cumulative Distribution Function")
clear()
clear
p_keyword <- 0.10
n_sites <- 10
probability_at_least_three <- 1 - pbinom(2, n_sites, p_keyword)
probability_at_least_three
probability_none_found <- dbinom(0, 10, 0.1)
probability_none_found
p_keyword
p_keyword
desired_prob <- 0.90
pbinom(0, 15, 0.1, lower.tail = FALSE)
pbinom(0, 25, 0.1, lower.tail = FALSE)
pbinom(0, 20, 0.1, lower.tail = FALSE)
pbinom(0, 21, 0.1, lower.tail = FALSE)
pbinom(0, 23, 0.1, lower.tail = FALSE)
pbinom(0, 22, 0.1, lower.tail = FALSE)
pgeom(2, 0.1)
pgeom(2, 0.1, lower.tail = FALSE)
pgeom(2, 0.1, lower.tail = FALSE)
qgeom(0.9, 0.1)
probability_first_three <- sum(dgeom(1:3, 0.10))
probability_first_three
pgeom(1:3, 0.1)
dpois(5, 6)
dpois(10, 9)
ppois(1, 3)
p_success <- 0.01
n_trial <- 200
probability_at_least_4_defective_binomial <- 1 - pbinom(3, n_trial, p_success)
probability_at_least_4_defective_binomial
lambda_poisson <- n_trials * p_success
n_trial
p_success
lambda_poisson <- n_trial * p_success
probability_at_least_4_defective_poisson <- 1 - ppois(3, lambda_poisson)
probability_at_least_4_defective_poisson
FX <- function(x) {
if (x < 0) {
return(0)
} else if (x >= 0 && x <= 2) {
return((1/4) * x^2)
} else {
return(1)
}
}
integrand <- function(x)(x/2)
integrate(integrand, 0, 1)
1 - integrate(integrand, 0, 3/2)
integrate(integrand, 0, 3/2)
1 - 0.5626
1 - 0.5625
7/16
mean_A <- 100
var_A <- 256
mean_B <- 150
var_B <- 260
P_A <- 0.4
P_B <- 1 - P_A
Z_X <- (120 - mean_A) / sqrt(var_A)
Z_Y <- (120 - mean_B) / sqrt(var_B)
P_X_less_than_120 <- pnorm(Z_X)
P_Y_less_than_120 <- pnorm(Z_Y)
P_signal_less_than_120 <- (P_X_less_than_120*P_A) + (P_Y_less_than_120*P_B)
P_signal_less_than_120
lambda <- 1/140
probability_second_quantum <- integrate(function(x) (1/140) * exp(-x/140), lower=100, upper=200)$value
probability_second_quantum
lambda <- 1/140
1 - exp(-100 * (lambda))
mean <- 5*(10^6)
stddev <- 5*(10^5)
z <- (4*(10^6))
z <- (4*(10^6) - mean)/stddev
z
P_deal_made <- 1 - pnorm(z)
P_deal_made
punif(0, -(pi), 1) - punif((-pi), -(pi), 1)
lambda
exp(-100*lambda)
lambda
exp(-100*lambda)
lambda*800
F_100 <- exp(-188*lambda)
F_100
F_100*800
F_100 <- exp(-100*lambda)
F_100*800
x <- c(100, 200, 400, 700)
y <- c(200, 300, 500, 700)
probability_x <- c(0.2, 0.4, 0.3, 0.1)
probability_y <- c(0.1, 0.2, 0.5, 0.2)
mean_x <- sum(x*probability_x)
mean_y <- sum(y*probability_y)
variance_x <- sum((x-mean_x)^2 *probability_x)
variance_y <- sum((y-mean_y)^2 *probability_y)
mean_x
mean_y
variance_x
variance_y
y <- c(200, 300, 500, 1000)
mean_y <- sum(y*probability_y)
variance_y
x
probability_x
mean_x
variance_x
mean_y <- sum(y*probability_y)
variance_y <- sum((y-mean_y)^2 *probability_y)
y
probability_y
mean_y
variance_y
xfx <- function(x)(x * (6x*(1-x)))
xfx <- function(x)(x * (6x*(1-x)))
xfx <- function(x)(x * (6x(1-x)))
xfx <- function(x)(x * (6*x*(1-x)))
xfx <- function(x)(x * (6*x*(1-x)))
integrate(xfx, 0, 1)
yfx = function(x)(x * ((6*x*(1-x))^2)
lkl
yfx = function(x)(x * ((6*x*(1-x))^2))
integrate(yfx, 0, 1)
deviations <- function(x)((x - 4.13333)^2 * (0.025*x + 0.15))
xfx <- function(x)(x * (6*x*(1-x)))
deviations <- function(x)((x - 0.5)^2 * (6*x*(1-x)))
integrate(deviations, 0, 1)
yfx <- function(x)(x * (6*x*x*(1-x)))
integrate(yfx, 0, 1)
yfx <- function(x)(x * (36*x*x*(x*x - 2*x + 1)))
integrate(yfx, 0, 1)
mean <- 350
stdev <- 3.75
low <- 345
high <- 355
z1 <- (low - mean) / stdev
z2 <- (high - mean) / stdev
prob <- pnorm(z2) - pnorm(z1)
prob
z <- -0.8/0.4243
pnorm(z)
pnorm(z)*2
mean <- 100
stdev <- 8.1650
pnorm (120, mean, stdev)
1-pnorm (120, mean, stdev)
x
probability_x
mean_x <- sum(x*probability_x)
variance_x <- sum((x-mean_x)^2 *probability_x)
mean_x
variance_x
y
probability_y
mean_y <- sum(y*probability_y)
variance_y <- sum((y-mean_y)^2 * probability_y)
mean_y
variance_y
cfx <- function(mean_x)(55*mean_x + 250)
cfx
integrate(cfx, 100, 700)
integrate(cfx, 0, 1)
55*mean_x  +250
mean_C = 55*mean_x+250
var_C = 55^2 * variance_x
mean_C
var_C
mean_P = 200*mean_x + 350*mean_y
var_P = 200^2*variance_x + 350^2*variance_y
mean_P
var_P
xfx
integrate(xfx, 0, 1)
yfx <- xfx^2
yfx <- function(x)((6*x*(1-x))^2)
integrate(yfx, 0, 1)
yfx <- function(x)(x * (6*x*(1-x))^2)
integrate(yfx, 0, 1)
var <- integrate(yfx, 0, 1) - integrate(xfx, 0, 1)
var <- 0.6 - 0.5
var
var <- 0.6 - (0.5)^2
var
p_values <- seq(0.01, 0.08, by = 0.01)
d_values <- c(0, 1, 2, 3)
s <- 120
n <- 2000
binomial_prob <- function(p, d, s, n) {
p_accept <- sum(dbinom(d:(s-1), size = s, prob = p))
return(1 - p_accept)
}
par(mfrow = c(1, 4), mar = c(5, 4, 2, 2))
for (d in d_values) {
oc_values <- sapply(p_values, function(p) binomial_prob(p, d, s, n))
plot(p_values, oc_values, type = "l", col = "blue", xlab = "Proportion of Defectives (p)",
ylab = "Probability of Acceptance", main = paste("d =", d))
}
p_values <- seq(0.01, 0.08, by = 0.01)
d_values <- c(0, 1, 2, 3)
s <- 120
n <- 2000
binomial_prob <- function(p, d, s, n) {
p_accept <- sum(dbinom(d:(s-1), size=s, prob=p))
return(1 - p_accept)
}
par(mfrow = c(1, 4), mar = c(5, 4, 2, 2))
for (d in d_values) {
oc_values <- sapply(p_values, function(p) binomial_prob(p, d, s, n))
plot(p_values, oc_values, type = "l", col = "blue", xlab = "Proportion of Defectives (p)", ylab = "Probability of Acceptance", main = paste("d =", d))
}
part b:
part b
s_values <- c(100, 120, 150, 200)
d <- 2
p_values <- seq(0.01, 0.08, by = 0.01)
d_values <- c(0, 1, 2, 3)
s <- 120
n <- 2000
binomial_prob <- function(p, d, s, n) {
p_accept <- sum(dbinom(d:(s-1), size=s, prob=p))
return(1 - p_accept)
}
par(mfrow = c(1, 4)
for (d in d_values) {
oc_values <- sapply(p_values, function(p) binomial_prob(p, d, s, n))
plot(p_values, oc_values, type = "l", col = "blue", xlab = "Proportion of Defectives (p)", ylab = "Probability of Acceptance", main = paste("d =", d))
}
for (d in d_values) {
oc_values <- sapply(p_values, function(p) binomial_prob(p, d, s, n))
plot(p_values, oc_values, type = "l", col = "blue", xlab = "Proportion of Defectives (p)",
ylab = "Probability of Acceptance", main = paste("d =", d))
}
par(mfrow = c(1, 4), mar = c(5, 4, 2, 2))
for (d in d_values) {
oc_values <- sapply(p_values, function(p) binomial_prob(p, d, s, n))
plot(p_values, oc_values, type = "l", col = "blue", xlab = "Proportion of Defectives (p)",
ylab = "Probability of Acceptance", main = paste("d =", d))
}
s_values <- c(100, 120, 150, 200)
d <- 2
par(mfrow = c(1, 4), mar = c(5, 4, 2, 2))
for (s in s_values) {
oc_values <- sapply(p_values, function(p) binomial_prob(p, d, s, n))
plot(p_values, oc_values, type = "l", col = "blue", xlab = "Proportion of Defectives (p)",
ylab = "Probability of Acceptance", main = paste("s =", s))
}
for (s in s_values) {
oc_values <- sapply(p_values, function(p) binomial_prob(p, d, s, n))
plot(p_values, oc_values, type = "l", col = "blue", xlab = "Proportion of Defectives (p)",
ylab = "Probability of Acceptance", main = paste("s =", s))
}
s_values <- c(100, 120, 150, 200)
d <- 2
s_values <- c(100, 120, 150, 200)
d <- 2
par(mfrow = c(1, 4), mar = c(5, 4, 2, 2))
for (s in s_values) {
oc_values <- sapply(p_values, function(p) binomial_prob(p, d, s, n))
plot(p_values, oc_values, type = "l", col = "blue", xlab = "Proportion of Defectives (p)",
ylab = "Probability of Acceptance", main = paste("s =", s))
}
p_values <- seq(0.01, 0.08, by = 0.01)
d_values <- c(0, 1, 2, 3)
s <- 120
n <- 2000
binomial_prob <- function(p, d, s, n) {
p_accept <- sum(dbinom(d:(s-1), size = s, prob = p))
return(1 - p_accept)
}
par(mfrow = c(1, 4), mar = c(5, 4, 2, 2))
for (d in d_values) {
oc_values <- sapply(p_values, function(p) binomial_prob(p, d, s, n))
plot(p_values, oc_values, type = "l", col = "blue", xlab = "Proportion of Defectives (p)",
ylab = "Probability of Acceptance", main = paste("d =", d))
}
library(markovchain)
library(markovchain)
install.packages("markovchain")
DTMC_P <- matrix(c(0.6, 0.2, 0.2, 0.3, 0.4, 0.3, 0, 0.3, 0.7), nrow=3, byrow=TRUE)
DTMC_P
dtmcP<-new("markovchain",transitionMatrix=DTMC_P, states=c("1","2","3"),name="HW5.Question2")
library(markovchain)
dtmcP<-new("markovchain",transitionMatrix=DTMC_P, states=c("1","2","3"),name="HW5.Question2")
DTMC_P <- matrix(c(0.6, 0.2, 0.2, 0.3, 0.4, 0.3, 0, 0.3, 0.7), nrow=3, byrow=TRUE)
DTMC_P
dtmcP<-new("markovchain",transitionMatrix=DTMC_P, states=c("1","2","3"),name="HW5.Question2")
dtmcP
plot(dtmcP)
plot(dtmcP)
plot(dtmcP)
plot(dtmcP)
plot(dtmcP)
plot(dtmcP)
plot(dtmcP)
dtmcP[2,3]
dtmcP[1,2]
pi<-steadyStates(dtmcP)
pi
3/13
4/13
6/13
dtmcP[1,2]*initialState[1]
dtmcP[1,2]*pi[1]
